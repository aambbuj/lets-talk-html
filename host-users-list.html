<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Users </title>
  <link rel="icon" href="/assets/imgs/favicon.png">
  <script src="js/config.js"></script>
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <style>
    body { margin:0; font-family: 'Segoe UI', sans-serif; background:linear-gradient(to bottom, #f8c6d8, #fddae3); }
    .container { max-width:440px; margin:0 auto; padding:16px; }
    .header { font-size:22px; font-weight:800; color:#fff; padding:14px; text-align:center; background:#d6006d; border-radius:12px; }
    .search { margin:12px 0; }
    .search input { width:100%; padding:12px; border:1px solid #ffd4e6; border-radius:12px; background:#fff; }
    .list { display:flex; flex-direction:column; gap:12px; }
    .card { display:flex; gap:9px; padding:12px; background:#fff; border-radius:12px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); align-items:center; position: relative; }
    .card img { width:60px; height:60px; border-radius:10px; object-fit:cover; }
    .info { flex:1; }
    .name { font-weight:700; color:#0f172a; font-size:15px; display:flex; align-items:center; gap:8px; }
    .meta { font-size:12px; color:#475569; }
    .status { font-size:12px; color:#475569; margin-top:4px; }
    .dot { display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; background:#9ca3af; }
    .dot.online { background:#22c55e; }
    .actions { display:flex; gap:8px; position: relative; }
    .btn { background:#d6006d; color:#fff; border:none; padding: 6px 6px; border-radius:10px; cursor:pointer; margin-left: -4px; font-size:12px; }
    .badge { background:#ef4444; color:#fff; border-radius:12px; padding:2px 6px; font-size:11px; font-weight:700; line-height:1; }
    
    /* Message count styles */
    .message-count {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #ef4444;
      color: white;
      border-radius: 50%;
      min-width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 10;
    }
    
    .message-count.hidden {
      display: none;
    }
    
    .message-preview {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
      padding: 4px 8px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 3px solid #d6006d;
      max-width: 250px;
      line-height: 1.3;
      word-wrap: break-word;
      white-space: normal;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    
    .message-preview-container {
      margin-top: 6px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }
    
    .message-preview-avatar {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #d6006d;
      flex-shrink: 0;
      margin-top: 2px;
    }
    
    .message-preview-content {
      flex: 1;
      min-width: 0;
    }
    
    .message-preview-sender {
      font-size: 10px;
      color: #d6006d;
      font-weight: 600;
      margin-bottom: 2px;
    }
    
    .message-preview-text {
      font-size: 11px;
      color: #666;
      line-height: 1.3;
      word-wrap: break-word;
      white-space: normal;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    
    .message-preview-time {
      font-size: 9px;
      color: #999;
      margin-top: 2px;
      font-style: italic;
    }
    
    .unread-indicator {
      background: #d6006d;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      position: absolute;
      top: 8px;
      right: 8px;
    }
    
    .unread-indicator.hidden {
      display: none;
    }
    
      .goog-logo-link,
    .goog-te-gadget span {
      display: none !important;
    }

    #google_translate_element {
      color: transparent !important;
    }

    .goog-te-gadget {
      color: #66666600 !important;
    }
    .footer-nav {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      background: #f84d91;
      width: 100%;
      max-width: 400px;
      height: 60px;
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 0 10px;
      box-shadow: 0 -2px 10px #00000030;
      z-index: 1000;
    }

    .footer-item {
      width: 40px;
      height: 40px;
      background: #ffffffaa;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 2px 5px #00000020;
      cursor: pointer;
    }

    .footer-item img {
      width: 20px;
      height: 20px;
    }

    .footer-center {
      width: 60px;
      height: 60px;
      background: #fff;
      border-radius: 50%;
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      box-shadow: 0 4px 8px #00000030;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2;
    }

    .footer-center img {
      width: 30px;
      height: 30px;
    }
    @media (max-width:768px){
      .card img {
    width: 50px;
    height: 50px;
    border-radius: 10px;
    object-fit: cover;
}
    }
    
  </style>
  <script>
    let allUsers = [];
    let me = { id: null, profileId: null, name: null };
    let online = new Set();
    let socket;
    let unreadCounts = {}; // key: user_profile_id (string) -> number
    let lastMessages = {}; // key: user_profile_id (string) -> { message: string, timestamp: number }
    let messageCounts = {}; // key: user_profile_id (string) -> total message count

    function storageKey(){ return `unreadCounts_${String(me.profileId||'')}`; }
    function loadUnread(){
      try {
        const raw = localStorage.getItem(storageKey());
        unreadCounts = raw ? JSON.parse(raw) : {};
      } catch(_) { unreadCounts = {}; }
    }
    function saveUnread(){
      try { localStorage.setItem(storageKey(), JSON.stringify(unreadCounts)); } catch(_){}
    }

    function loadLastMessages(){
      try {
        const raw = localStorage.getItem(`lastMessages_${String(me.profileId||'')}`);
        lastMessages = raw ? JSON.parse(raw) : {};
      } catch(_) { lastMessages = {}; }
    }
    function saveLastMessages(){
      try { localStorage.setItem(`lastMessages_${String(me.profileId||'')}`, JSON.stringify(lastMessages)); } catch(_){}
    }

    function loadMessageCounts(){
      try {
        const raw = localStorage.getItem(`messageCounts_${String(me.profileId||'')}`);
        messageCounts = raw ? JSON.parse(raw) : {};
      } catch(_) { messageCounts = {}; }
    }
    function saveMessageCounts(){
      try { localStorage.setItem(`messageCounts_${String(me.profileId||'')}`, JSON.stringify(messageCounts)); } catch(_){}
    }

    // Update unread count for a specific user
    function updateUnreadCount(userProfileId, increment = 1) {
      const key = String(userProfileId);
      if (key) {
        unreadCounts[key] = Number(unreadCounts[key] || 0) + increment;
        saveUnread();
        render(allUsers);
      }
    }

    // Clear unread count for a specific user
    function clearUnreadCount(userProfileId) {
      const key = String(userProfileId);
      if (key) {
        unreadCounts[key] = 0;
        saveUnread();
        render(allUsers);
      }
    }

    // Update last message for a specific user
    function updateLastMessage(userProfileId, message, timestamp = Date.now()) {
      const key = String(userProfileId);
      if (key) {
        lastMessages[key] = { message, timestamp };
        saveLastMessages();
        render(allUsers);
      }
    }

    // Update message count for a specific user
    function updateMessageCount(userProfileId, increment = 1) {
      const key = String(userProfileId);
      if (key) {
        messageCounts[key] = Number(messageCounts[key] || 0) + increment;
        saveMessageCounts();
        render(allUsers);
      }
    }

    function formatLastMessageTime(timestamp) {
      if (!timestamp) return '';
      const now = Date.now();
      const diff = now - timestamp;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (minutes < 1) return 'Just now';
      if (minutes < 60) return `${minutes}m ago`;
      if (hours < 24) return `${hours}h ago`;
      if (days < 7) return `${days}d ago`;
      
      return new Date(timestamp).toLocaleDateString();
    }

    async function startCall(user){
      try {
        const sender_id = Number(me.id || localStorage.getItem('userId'));
        const receiver_id = Number(user.id);
        const roomResp = await fetch(API_CONFIG.getAuthUrl('/room/create'), { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ sender_id, receiver_id }) });
        const roomData = await roomResp.json();
        const roomName = roomData?.data?.name || `room_${Math.min(sender_id,receiver_id)}_${Math.max(sender_id,receiver_id)}`;
        window.location.href = `room-video.html?room=${encodeURIComponent(roomName)}&name=${encodeURIComponent(me.name||'Me')}&peer=${encodeURIComponent(user.name||'User')}`;
      } catch(_){
        const sender_id = Number(me.id || localStorage.getItem('userId'));
        const receiver_id = Number(user.id);
        const a = Math.min(sender_id, receiver_id), b = Math.max(sender_id, receiver_id);
        const fallback = (Number.isFinite(a)&&Number.isFinite(b))?`room_${a}_${b}`:`room_${user.user_profile_id||user.id}`;
        window.location.href = `room-video.html?room=${encodeURIComponent(fallback)}&name=${encodeURIComponent(me.name||'Me')}&peer=${encodeURIComponent(user.name||'User')}`;
      }
    }

    async function startChat(user){
      try {
        const sender_id = Number(me.id || localStorage.getItem('userId'));
        const receiver_id = Number(user.id);
        let roomName = '';
        try {
          const roomResp = await fetch(API_CONFIG.getAuthUrl('/room/create'), {
            method:'POST', 
            headers:{ 
              'Content-Type':'application/json',
              'Authorization': `Bearer ${localStorage.getItem('authToken') || localStorage.getItem('userToken')}`
            }, 
            body: JSON.stringify({ sender_id, receiver_id })
          });
          const roomData = await roomResp.json();
          roomName = (roomData && roomData.data && typeof roomData.data.name === 'string') ? roomData.data.name : '';
        } catch(_) {}
        if (!roomName) {
          const a = Math.min(sender_id, receiver_id), b = Math.max(sender_id, receiver_id);
          roomName = (Number.isFinite(a) && Number.isFinite(b)) ? `room_${a}_${b}` : `room_${user.user_profile_id||user.id}`;
        }
        try {
          if (socket && me.profileId && user.user_profile_id) {
            socket.emit('chat-invite', { from: String(me.profileId), fromName: me.name, to: String(user.user_profile_id), roomName });
          }
        } catch(_){}
        // Clear unread count for this user since we are opening the chat
        try {
          const key = String(user.user_profile_id||'');
          if (key) { unreadCounts[key] = 0; saveUnread(); }
        } catch(_){ }
        window.location.href = `room-chat.html?room=${encodeURIComponent(roomName)}&name=${encodeURIComponent(me.name||'Me')}&peer=${encodeURIComponent(user.name||'User')}&mode=chat&userId=${sender_id}&peerId=${receiver_id}`;
      } catch(_){
        const sender_id = Number(me.id || localStorage.getItem('userId'));
        const receiver_id = Number(user.id);
        const a = Math.min(sender_id, receiver_id), b = Math.max(sender_id, receiver_id);
        const fallback = (Number.isFinite(a)&&Number.isFinite(b))?`room_${a}_${b}`:`room_${user.user_profile_id||user.id}`;
        window.location.href = `room-chat.html?room=${encodeURIComponent(fallback)}&name=${encodeURIComponent(me.name||'Me')}&peer=${encodeURIComponent(user.name||'User')}&mode=chat&userId=${sender_id}&peerId=${receiver_id}`;
      }
    }

    function render(list) {
      const root = document.getElementById('list');
      root.innerHTML = '';
      if (!list || list.length===0) { root.innerHTML = '<p style="text-align:center;color:#475569;">No users found.</p>'; return; }
      list.forEach(u => {
        const img = (u.Images && u.Images.length>0 && u.Images[0].url) ? u.Images[0].url : 'imgs/logo11.png';
        const el = document.createElement('div');
        el.className = 'card';
        const onlineDot = online.has(String(u.user_profile_id||'')) ? 'online' : '';
        const unread = Number(unreadCounts[String(u.user_profile_id||'')] || 0);
        const lastMessage = lastMessages[String(u.user_profile_id||'')];
        const messageCount = Number(messageCounts[String(u.user_profile_id||'')] || 0);

        el.innerHTML = `
          <img src="${img}" alt="${u.name||'User'}"/>
          <div class="info">
            <div class="name">${u.name||'User'}</div>
            <div class="meta">${u.email||''}</div>
            <div class="status"><span class="dot ${onlineDot}"></span>${onlineDot?'Online':'Offline'}</div>
            ${lastMessage ? `
              <div class="message-preview-container">
                <div class="message-preview-avatar"></div>
                <div class="message-preview-content">
                  <div class="message-preview-sender">${u.name||'User'}</div>
                  <div class="message-preview-text">${lastMessage.message}</div>
                  <div class="message-preview-time">${formatLastMessageTime(lastMessage.timestamp)}</div>
                </div>
              </div>
            ` : ''}
          </div>
          <div class="actions">
            <button class="btn" onclick='startCall(${JSON.stringify(u)})'>Call</button>
            <button class="btn" onclick='startChat(${JSON.stringify(u)})'>Chat</button>
            ${unread > 0 ? `<div class="message-count">${unread > 99 ? '99+' : unread}</div>` : ''}
            ${unread === 0 && messageCount > 0 ? '<div class="unread-indicator"></div>' : ''}
          </div>
        `;
        root.appendChild(el);
      });
    }

    async function loadUsers() {
      const token = localStorage.getItem('authToken') || localStorage.getItem('userToken');
      if (!token) { window.location.href='User/userlogin.html'; return; }
      try {
        const myRes = await fetch(API_CONFIG.getAuthUrl('/show-profile'), { headers: { 'Authorization': `Bearer ${token}` } });
        const myData = await myRes.json();
        if (myRes.ok && myData?.data) { me.id = myData.data.id; me.profileId = myData.data.user_profile_id; me.name = myData.data.name; }
      } catch(_){ }
      // Load unread counts after we know our profile id
      loadUnread();
      loadLastMessages();
      loadMessageCounts();
      const res = await fetch(API_CONFIG.getAuthUrl('/user-list-for-host'), { headers: { 'Authorization': `Bearer ${token}` } });
      const data = await res.json();
      allUsers = data?.data || [];
      render(allUsers);
      // Initialize presence via socket if available
      try {
        socket = io(API_CONFIG.getBaseUrl(), { path:'/socket.io', upgrade:false, transports:['polling'] });
        if (me.profileId) {
          socket.emit('register', me.profileId, String(me.id||''));
        }
        // Online presence list
        socket.on('user-list', (names) => {
          try {
            online = new Set((names||[]).map(x => String(x)));
            render(allUsers);
          } catch(_){}
        });
        // Incoming chat invites
        socket.on('incoming-chat', ({ from, fromName, roomName }) => {
          try {
            const key = String(from||'');
            if (key) {
              unreadCounts[key] = Number(unreadCounts[key] || 0) + 1;
              saveUnread();
              render(allUsers);
            }
          } catch(_){ }
        });
        
        // Handle incoming messages
        socket.on('room-message', (data) => {
          try {
            // Extract user ID from room name (room_123_456 format)
            const roomParts = data.roomName.split('_');
            if (roomParts.length >= 3) {
              const id1 = parseInt(roomParts[1]);
              const id2 = parseInt(roomParts[2]);
              let senderProfileId = null;
              
              // Determine which user sent the message
              if (id1 === me.id) {
                senderProfileId = id2;
              } else if (id2 === me.id) {
                senderProfileId = id1;
              }
              
              if (senderProfileId) {
                // Find the user by ID to get their profile ID
                const user = allUsers.find(u => u.id === senderProfileId);
                if (user && user.user_profile_id) {
                  const profileKey = String(user.user_profile_id);
                  updateUnreadCount(profileKey, 1);
                  updateLastMessage(profileKey, data.message, data.timestamp || Date.now());
                  updateMessageCount(profileKey, 1);
                }
              }
            }
          } catch(_){ }
        });
      } catch(_){ }
    }
    
    function onSearch(v){ const q=(v||'').toLowerCase(); if(!q) return render(allUsers); render(allUsers.filter(u=> (u.name||'').toLowerCase().includes(q) || (u.email||'').toLowerCase().includes(q))); }
    
    // Function to manually refresh message counts (can be called periodically)
    async function refreshMessageCounts() {
      if (!me.profileId) return;
      
      try {
        // You can implement API calls here to sync message counts with the server
        // For now, we'll just re-render with existing data
        render(allUsers);
      } catch(_){ }
    }
    
    // Refresh message counts every 30 seconds
    setInterval(refreshMessageCounts, 30000);
    
    document.addEventListener('DOMContentLoaded', loadUsers);

     function googleTranslateElementInit() {
    new google.translate.TranslateElement({ pageLanguage: 'en', autoDisplay: false }, 'google_translate_element');
  }
  </script>
</head>
<body>
  <div class="header">Users</div>
  <div class="container">
      <div id="google_translate_element"></div>
    <div class="search"><input placeholder="Search user..." oninput="onSearch(this.value)"/></div>
    <div id="list" class="list"></div>
      <!-- Footer Navigation -->
  <div class="footer-nav">
    <div class="footer-item"><a href="call-list.html"><img src="icons/video.png" alt="Video"></a></div>
    <div class="footer-item"><a href="my-chats.html"><img src="icons/chat.png" alt="Chat"></a></div>

    <div class="footer-center">
     <a href="host-users.html"> <img src="imgs/logo11.png" alt="Main" /></a>
    </div>

    <div class="footer-item"><a href="notifications.html" class="blink-bell">
    <img src="icons/bell.png" alt="Notification">
  </a></div>  
    <div class="footer-item"><a href="profile1.html"><img src="icons/user.png" alt="Profile"></a></div>
  </div>
  </div>

</body>
</html>


